{
  "version": "1.12.0",
  "compound": {
    "kind": "page",
    "id": "interrupts_page",
    "name": "Overview of Interrupts",
    "url_base": "interrupts_page",
    "url": "interrupts_page.html",
    "include": null,
    "has_template_details": false,
    "templates": null,
    "brief": "",
    "description": "<p><a name=\"md_docs_2_overview_of_interrupts\"></a></p><section id=\"interrupts_what\"><h2>What is an Interrupt?</h2><p>An interrupt is a signal that causes the microcontroller to halt execution of the program, and perform a subroutine known as an interrupt handler or Interrupt Service Routine (ISR). After the ISR, program execution continues where it left off. This allows the microcontroller to efficiently handle a time-sensitive function such as receiving a burst of data on one of its pins, by not forcing the microcontroller to wait for the data. It can perform other tasks until the interrupt is called.</p><p>All processors running some sort of Arduino core can support multiple type of interrupts. This library specifically makes us of pin change interrupts - interrupts that trigger an ISR on any change of state detected for a specified pin.</p><p>Obviously, we don&#x27;t want the processor to be halting operation every time any pin changes voltage, so we can disable or enable interrupts on a pin-by-pin basis. For Atmel SAMD or Espressif processors the processor has dedicated control registers for each pin and the Arduino core provides us with a handy &quot;attachInterrupt&quot; function to use to tie our ISR to that pin. For AVR processors, like the Arduino Uno or the EnviroDIY Mayfly, we have to use a get a bit fancier to control the interrupts.</p></section><section id=\"interrupts_avr\"><h2>Directly Controlling Interrupts on an AVR Board</h2><section id=\"interrupts_vocab\"><h3>Some Vocabulary:</h3><p><strong>Registers</strong>: small 1-byte (8-bit) stores of memory directly accessible by processor PCMSK0, PCMSK1, PCMSK2, PCMSK3</p><p><code>PCICRx</code>: a register where the three least significant bits enable or disable pin change interrupts on a range of pins</p><ul><li>i.e. {0,0,0,0,0,PCIE2,PCIE1,PCIE0}, where PCIE2 maps to PCMSK2, PCIE1 maps to PCMSK1, and PCIE0 maps to PCMSK0.</li></ul><p><code>PCMSKx</code>: a register that stores the state (enabled/disabled) of pin change interrupts on a single pin</p><ul><li>Each bit stores a 1 (enabled) or 0 (disabled).</li></ul><p>On an Arduino Uno:</p><ul><li>There is on PCICR register controlling three ranges of pins</li><li>There are three mask registers (PCMSK0, PCMSK1, and PCMSK2) controlling individual pins.</li><li>Looking at one mask register, PCMSK0:<ul><li>the 8 bits represent: PCMSK0 {PCINT7, PCINT6, PCINT5, PCINT4, PCINT3, PCINT2, PCINT1, PCINT0}</li><li>these map to: PCMSK0 {XTAL2, XTAL1, Pin 13, Pin 12, Pin 11, Pin 10, Pin 9, Pin 8}</li></ul></li></ul><p><code>noInterrupts()</code>: a function to globally disable interrupts (of all types)</p><p><code>interrupts()</code>: a function to globally enable interrupts (of all types)</p><ul><li>interrupts will only occur if the requisite registers are set (e.g. PCMSK and PCICR).</li></ul></section><section id=\"interrupts_enable\"><h3>Enabling an Interrupt</h3><p>Initially, no interrupts are enabled, so PCMSK0 looks like: <code>{00000000}</code>. If we were to use pin 9 as the data pin, we would set the bit in the pin 9 position to 1, like so: <code>{00000010}</code>.</p><p>To accomplish this, we can make use of some predefined macros.</p><p>One macro <code>digitalPinToPCMSK</code> is defined in &quot;pins_arduino.h&quot; which allows us to quickly get the proper register (PCMSK0, PCMSK1, or PCMSK2) given the number of the Arduino pin. So when we write: <code>digitalPinToPCMSK(9)</code>, the address of PCMSK0 is returned. We can use the dereferencing operator &#x27;*&#x27; to get the value of the address.</p><p>That is, <code>*digitalPinToPCMSK(9)</code> returns: <code>{00000000}</code>.</p><p>Another macro , <code>digitalPinToPCMSKbit</code> is also defined in &quot;pins_arduino.h&quot; and returns the position of the bit of interest within the PCMSK of interest.</p><p>So when we write: <code>digitalPinToPCMSKbit(9)</code>, the value returned is 1, because pin 9 is represented by the &quot;1st bit&quot; within PCMSK0, which has a zero-based index. That is: PCMSK { 7th bit, 6th bit, 5th bit, 4th bit, 3rd bit, 2nd bit, 1st bit, 0th bit }</p><p>The leftward bit shift operator <code>&lt;&lt;</code> can then used to create a &quot;mask&quot;. Masks are data that are used during bitwise operations to manipulate (enable / disable) one or more individual bits simultaneously.</p><p>The syntax for the operator is (variable &lt;&lt; number_of_bits). Some examples:</p><div class=\"m-code-arduino\"><div class=\"highlight\"><div class=\"line\"><a id=\"l-1\" name=\"l-1\"></a><span class=\"linenos\">1</span><span class=\"n\">byte</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\">       </span><span class=\"c1\">// binary: a =  00000101</span>\n</div><div class=\"line\"><a id=\"l-2\" name=\"l-2\"></a><span class=\"linenos\">2</span>\n</div><div class=\"line\"><a id=\"l-3\" name=\"l-3\"></a><span class=\"linenos\">3</span><span class=\"n\">byte</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">;</span><span class=\"w\">  </span><span class=\"c1\">// binary: b =  01010000</span>\n</div></div></div><p>So when we write: <code>(1&lt;&lt;digitalPinToPCMSKbit(9))</code>, we get: <code>{00000010}</code>.</p><p>Or equivalently: <code>(1&lt;&lt;1)</code>, we get: <code>{00000010}</code>.</p><p>To use the mask to set the bit of interest we use the bitwise or operator <code>|</code>. We will use the compact <code>|=</code> notation which does the operation and then stores the result back into the left hand side.</p><p>So the operation:</p><div class=\"m-code-arduino\"><div class=\"highlight\"><div class=\"line\"><a id=\"l-1\" name=\"l-1\"></a><span class=\"linenos\">1</span><span class=\"o\">*</span><span class=\"n\">digitalPinToPCMSK</span><span class=\"p\">(</span><span class=\"n\">_dataPin</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">|=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">&lt;&lt;</span><span class=\"n\">digitalPinToPCMSKbit</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">));</span>\n</div></div></div><p>Accomplishes:</p><div class=\"m-code-pygments-default\"><div class=\"highlight\"><div class=\"line\"><a id=\"l-1\" name=\"l-1\"></a><span class=\"linenos\">1</span>(1&lt;&lt;digitalPinToPCMSKbit(9))              {00000010}\n</div><div class=\"line\"><a id=\"l-2\" name=\"l-2\"></a><span class=\"linenos\">2</span>\n</div><div class=\"line\"><a id=\"l-3\" name=\"l-3\"></a><span class=\"linenos\">3</span>PCMSK0                               |    {00000000}\n</div><div class=\"line\"><a id=\"l-4\" name=\"l-4\"></a><span class=\"linenos\">4</span>\n</div><div class=\"line\"><a id=\"l-5\" name=\"l-5\"></a><span class=\"linenos\">5</span>                                         -------------\n</div><div class=\"line\"><a id=\"l-6\" name=\"l-6\"></a><span class=\"linenos\">6</span>\n</div><div class=\"line\"><a id=\"l-7\" name=\"l-7\"></a><span class=\"linenos\">7</span>                                          {00000010}\n</div></div></div><p>We must also enable the global control for the interrupt. This is done in a similar fashion:</p><p><code>*digitalPinToPCICR(_dataPin) |= (1&lt;&lt;digitalPinToPCICRbit(_dataPin));</code></p><p>Now let&#x27;s assume that part of your Arduino sketch outside of SDI-12 had set a pin change interrupt on pin 13. Pin 9 and pin 13 are on the same PCMSK in the case of the Arduino Uno.</p><p>This time before we set the bit for pin nine,</p><p><code>*digitalPinToPCMSK(9)</code> returns: <code>{00100000}</code>.</p><p>So now:</p><div class=\"m-code-pygments-default\"><div class=\"highlight\"><div class=\"line\"><a id=\"l-1\" name=\"l-1\"></a><span class=\"linenos\">1</span>(1&lt;&lt;digitalPinToPCMSKbit(9))              {00000010}\n</div><div class=\"line\"><a id=\"l-2\" name=\"l-2\"></a><span class=\"linenos\">2</span>\n</div><div class=\"line\"><a id=\"l-3\" name=\"l-3\"></a><span class=\"linenos\">3</span>PCMSK0                               |    {00100000}\n</div><div class=\"line\"><a id=\"l-4\" name=\"l-4\"></a><span class=\"linenos\">4</span>\n</div><div class=\"line\"><a id=\"l-5\" name=\"l-5\"></a><span class=\"linenos\">5</span>                                        -------------\n</div><div class=\"line\"><a id=\"l-6\" name=\"l-6\"></a><span class=\"linenos\">6</span>\n</div><div class=\"line\"><a id=\"l-7\" name=\"l-7\"></a><span class=\"linenos\">7</span>                                          {00100010}\n</div></div></div><p>By using a bitmask and bitwise operation, we have successfully enabled pin 9 without effecting the state of pin 13.</p></section><section id=\"interrupts_disable\"><h3>Disabling an Interrupt</h3><p>When the we would like to put the SDI-12 object in the DISABLED state, (e.g. the destructor is called), we need to make sure the bit corresponding to the data pin is unset.</p><p>Let us consider again the case of where an interrupt has been enabled on pin 13: <code>{00100010}</code>. We want to be sure not to disturb this interrupt when disabling the interrupt on pin 9.</p><p>We will make use of similar macros, but this time we will use an inverted bit mask and the AND operation. The <code>&amp;=</code> operator is equivalent to a bitwise AND operation between the PCMSK register of interest and the previous result, which is then stored back into the PCMSK of interest. The <code>*</code> is the dereferencing operator, which is equivalently translated to &quot;value pointed by&quot;, and allows us to store the result back into the proper PCMSK.</p><p>Again <code>1&lt;&lt;digitalPinToPCMSKbit(9)</code> returns <code>{00000010}</code></p><p>The inversion symbol <code>~</code> modifies the result to <code>{11111101}</code></p><p>So to finish our example:</p><div class=\"m-code-pygments-default\"><div class=\"highlight\"><div class=\"line\"><a id=\"l-1\" name=\"l-1\"></a><span class=\"linenos\">1</span>~(1&lt;&lt;digitalPinToPCMSKbit(9))             {11111101}\n</div><div class=\"line\"><a id=\"l-2\" name=\"l-2\"></a><span class=\"linenos\">2</span>\n</div><div class=\"line\"><a id=\"l-3\" name=\"l-3\"></a><span class=\"linenos\">3</span>PCMSK0                               &amp;    {00100010}\n</div><div class=\"line\"><a id=\"l-4\" name=\"l-4\"></a><span class=\"linenos\">4</span>\n</div><div class=\"line\"><a id=\"l-5\" name=\"l-5\"></a><span class=\"linenos\">5</span>                                        -------------\n</div><div class=\"line\"><a id=\"l-6\" name=\"l-6\"></a><span class=\"linenos\">6</span>\n</div><div class=\"line\"><a id=\"l-7\" name=\"l-7\"></a><span class=\"linenos\">7</span>                                          {00100000}\n</div></div></div><p>So only the interrupt on pin 13 remains set. As a matter of book keeping, if we unset the last bit in the PCMSK, we ought to also unset the respective bit in the PCICR.</p><p><code>!(*digitalPinToPCMSK(9)</code></p><ul><li>will evaluate TRUE if PCMSK == <code>{00000000}</code></li><li>will evaluate FALSE if PCMSK != <code>{00000000}</code></li></ul><p>In this case, pin 13 is set, so the expression would be FALSE. If we go back to the original case without pin 13, the expression after disabling pin 9 would evaluate to TRUE.</p><p>Therefore if we evaluate to TRUE, we should tidy up:</p><div class=\"m-code-arduino\"><div class=\"highlight\"><div class=\"line\"><a id=\"l-1\" name=\"l-1\"></a><span class=\"linenos\">1</span><span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!*</span><span class=\"n\">digitalPinToPCMSK</span><span class=\"p\">(</span><span class=\"n\">_dataPin</span><span class=\"p\">)){</span>\n</div><div class=\"line\"><a id=\"l-2\" name=\"l-2\"></a><span class=\"linenos\">2</span><span class=\"w\">      </span><span class=\"o\">*</span><span class=\"n\">digitalPinToPCICR</span><span class=\"p\">(</span><span class=\"n\">_dataPin</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;=</span><span class=\"w\"> </span><span class=\"o\">~</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">&lt;&lt;</span><span class=\"n\">digitalPinToPCICRbit</span><span class=\"p\">(</span><span class=\"n\">_dataPin</span><span class=\"p\">));</span>\n</div><div class=\"line\"><a id=\"l-3\" name=\"l-3\"></a><span class=\"linenos\">3</span><span class=\"w\">  </span><span class=\"p\">}</span>\n</div></div></div></section></section>",
    "sections": [
      [
        "interrupts_what",
        "What is an Interrupt?",
        []
      ],
      [
        "interrupts_avr",
        "Directly Controlling Interrupts on an AVR Board",
        [
          [
            "interrupts_vocab",
            "Some Vocabulary:",
            []
          ],
          [
            "interrupts_enable",
            "Enabling an Interrupt",
            []
          ],
          [
            "interrupts_disable",
            "Disabling an Interrupt",
            []
          ]
        ]
      ]
    ],
    "deprecated": null,
    "since": null,
    "example_navigation": null,
    "footer_navigation": null,
    "topics": [],
    "dirs": [],
    "files": [],
    "namespaces": [],
    "classes": [],
    "base_classes": [],
    "derived_classes": [],
    "enums": [],
    "typedefs": [],
    "funcs": [],
    "vars": [],
    "defines": [],
    "public_types": [],
    "public_static_funcs": [],
    "typeless_funcs": [],
    "public_funcs": [],
    "signals": [],
    "public_slots": [],
    "public_static_vars": [],
    "public_vars": [],
    "protected_types": [],
    "protected_static_funcs": [],
    "protected_funcs": [],
    "protected_slots": [],
    "protected_static_vars": [],
    "protected_vars": [],
    "private_funcs": [],
    "private_slots": [],
    "related": [],
    "friend_funcs": [],
    "groups": [],
    "has_enum_details": false,
    "has_typedef_details": false,
    "has_func_details": false,
    "has_var_details": false,
    "has_define_details": false,
    "breadcrumb": [
      [
        "Overview of Interrupts",
        "interrupts_page.html"
      ]
    ],
    "breadcrumbGroup": [
      [
        "Overview of Interrupts",
        "interrupts_page.html"
      ]
    ]
  }
}